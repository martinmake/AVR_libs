#ifndef _USART_USART0_H_
#define _USART_USART0_H_

#include <avr/io.h>

#include <util.h>

#include "usart/iusart.h"

class Usart0: virtual public IUsart
{
	public: // TYPES
		enum class X2            : uint8_t { OFF, ON };
		enum class Rx            : uint8_t { OFF, ON };
		enum class Tx            : uint8_t { OFF, ON };
		enum class StopBitSelect : uint8_t { S1, S2 };
		enum class CharacterSize : uint8_t { S5, S6, S7, S8, S9 };

		struct Init
		{
			X2            x2;
			Rx            rx;
			Tx            tx;
			CharacterSize character_size;
			StopBitSelect stop_bit_select;
			uint32_t      baud;
			uint32_t      f_osc;
			uint8_t       output_queue_size;
		};

	public: // CONSTRUCTORS
		Usart0(const Init* init);
		Usart0(uint32_t baud, uint32_t f_osc);

	public: // GETTERS
		FILE* stream(void) override;

	public: // FUNSTIONS
		void putchar(char c) override;
		char getchar(void  ) override;
		void flush  (void  ) override;

	public: // OPERATORS
		Usart0& operator<<(      char  c);
		Usart0& operator<<(const char* s);
		Usart0& operator>>(      char& c);
		Usart0& operator>>(      char* s);
};

inline void Usart0::putchar(char c)
{
	if (UCSR0A & (1 << UDRE0))
		UDR0 = c;
	else
		output_queue << c;
}
inline char Usart0::getchar(void)
{
	while ( ! (UCSR0A & (1 << RXC0)) ) {}
	return UDR0;
}

inline void Usart0::flush(void)
{
	uint8_t sreg_save = SREG;
	cli();
	while (!output_queue.is_empty())
	{
		while (IS_CLEAR(UCSR0A, UDRE0)) {}
		output_queue >> UDR0;
	}
	SREG = sreg_save;
}

inline Usart0& Usart0::operator<<(char c)
{
	putchar(c);

	return *this;
}
inline Usart0& Usart0::operator<<(const char* s)
{
	while (*s) putchar(*s++);

	return *this;
}

inline Usart0& Usart0::operator>>(char& c)
{
	c = getchar();

	return *this;
}

extern Usart0 usart0;

#endif
